import flixel.FlxG;
import funkin.graphics.FunkinSprite;
import flixel.tweens.FlxEase;
import flixel.tweens.FlxTween;
import flixel.util.FlxTimer;
import funkin.audio.FunkinSound;
import funkin.play.PlayState;
import funkin.play.PlayStatePlaylist;
import funkin.play.song.Song;
import funkin.Preferences;
import funkin.play.notes.StrumlineNote;
import funkin.Conductor;
import flixel.math.FlxPoint;
import funkin.play.GameOverSubState;

// Well, moving notes is fkin hell-
class QTTerminationSong extends Song {
    var inAngleRotating:Bool = false;
    var defPosArray:Map<Int, FlxPoint>;
    var fkinOpponentPosArray:Array<FlxPoint> = [];
    var fkinPlayerPosArray:Array<FlxPoint> = [];
    var pincer1:FunkinSprite;
    var pincer2:FunkinSprite;
    var pincer3:FunkinSprite;
    var pincer4:FunkinSprite;
    public function new() {
        super('termination');
    }

    override function onCreate(event:ScriptEvent):Void {
        super.onCreate(event);

        inAngleRotating = false;
        PlayState.instance.currentStage.getGirlfriend().animation.addByPrefix("scared-termination", "GF FEAR", 24, true);
        PlayState.instance.currentStage.getGirlfriend().setAnimationOffsets("scared-termination", -2, -17);
        createPincers();
        initDefArrowPos();
        nonVisibleStaticArrows();
        resetCameraAngle();
    }

    override function onSongRetry(event:ScriptEvent):Void {
        super.onSongRetry(event);

        inAngleRotating = false;
        restartPincers();
        nonVisibleStaticArrows();
        resetCameraAngle();
        PlayState.instance.currentStage.getGirlfriend().canPlayOtherAnims = true;
        PlayState.instance.currentStage.getGirlfriend().playAnimation('scared', true);
    }

    override function onUpdate(elapsed:Float):Void {
        super.onUpdate(elapsed);

        if (PlayState.instance != null) cameraAngleMovement();
    }

    override function onBeatHit(event:SongTimeScriptEvent):Void {
        super.onBeatHit(event);
        if ((event.beat > 24 && event.beat < 640) || event.beat > 1088) return;
        if (event.beat == 0 || event.beat == 8 || event.beat == 16 || event.beat == 24) terminationIntroShit(Std.int(event.beat / 8));
        switch (event.beat) {
            case 640:
                changeIdle("-alt");
            case 702:
                PlayState.instance.currentStage.scriptCall("revealError", [2]);
                shakeCameras(0.0133, 0.0132, 0.54);
                changeIdle("-angry");
                PlayState.instance.currentStage.getGirlfriend().forceAnimationForDuration("scared-termination", 35);
                setKBDrain(0.1);
            case 704:
                PlayState.instance.currentStage.scriptCall("revealError", [1]);
                setKBDrain(0.01, 1.1275);
            case 831:
                setKBDrain(0.0125, 1.2);
            case 832:
                PlayState.instance.currentStage.scriptCall("revealError", [0]);
                changeIdle("");
            case 834:
                PlayState.instance.currentStage.getGirlfriend().playAnimation('scared', true);
            case 1088:
                changeIdle("-alt");
        }
    }

    override function onStepHit(event:SongTimeScriptEvent):Void {
        super.onStepHit(event);
        if (event.step < 2039 || event.step > 2561) return;

        if (event.step == 2040) kbPincerState(22);
        else if (event.step == 2048) kbPincerState(23);
        else if (event.step == 2560) kbPincerState(24);
    }

    override function onNoteHit(event:HitNoteScriptEvent):Void {
        if (event.eventCanceled) return;

        if (event.note.kind == "qt_outro_fade") terminationOutroShit(event.note.noteData.data, event.note.noteData.getMustHitNote());
        super.onNoteHit(event);
    }

    function setKBDrain(drain:Float, loss:Float = null) {
        if (PlayState.instance.currentStage.getDad().characterId != "qt_kb") return;
        PlayState.instance.currentStage.getDad().scriptCall("setDrain", [drain, loss]);
    }

    function changeIdle(suffix:String) {
        var kb = PlayState.instance.currentStage.getDad();
        if (kb == null) return;
        kb.idleSuffix = suffix;
        kb.shouldAlternate = (suffix == "");
    }

    function shakeCameras(gameVal:Float, hudVal:Float, duration:Float = 0.63) {
        PlayState.instance.camGame.shake(gameVal, duration); PlayState.instance.camHUD.shake(hudVal, duration);
    }

    function createPincers() {
        pincer1 = new FunkinSprite(0, 0).loadTexture('hazardStuff/qt-port/pincer-close');
		pincer1.scrollFactor.set();

		pincer2 = new FunkinSprite(0, 0).loadTexture('hazardStuff/qt-port/pincer-close');
		pincer2.scrollFactor.set();

		pincer3 = new FunkinSprite(0, 0).loadTexture('hazardStuff/qt-port/pincer-close');
		pincer3.scrollFactor.set();

		pincer4 = new FunkinSprite(0, 0).loadTexture('hazardStuff/qt-port/pincer-close');
		pincer4.scrollFactor.set();

        restartPincers();
        pincer1.cameras = [PlayState.instance.camHUD];
		pincer2.cameras = [PlayState.instance.camHUD];
		pincer3.cameras = [PlayState.instance.camHUD];
		pincer4.cameras = [PlayState.instance.camHUD];
        PlayState.instance.add(pincer1);
        PlayState.instance.add(pincer2);
        PlayState.instance.add(pincer3);
        PlayState.instance.add(pincer4);
        PlayState.instance.refresh(); // idk
    }

    function restartPincers() {
        var daX:Float = (Preferences.downscroll ? 160 : 218);
        var daY:Float = (Preferences.downscroll ? -100 : 240);
        var daAngle:Float = (Preferences.downscroll ? 270 : 90);
        pincer1.angle = daAngle;
        pincer2.angle = daAngle;
        pincer3.angle = daAngle;
        pincer4.angle = daAngle;
        pincer1.offset.set(daX, daY);
        pincer2.offset.set(daX, daY);
        pincer3.offset.set(daX, daY);
        pincer4.offset.set(daX, daY);
        pincer1.visible = false;
        pincer2.visible = false;
        pincer3.visible = false;
        pincer4.visible = false;
        pincer1.zIndex = 2000;
        pincer2.zIndex = 2000;
        pincer3.zIndex = 2000;
        pincer4.zIndex = 2000;
    }

    function kbPincerState(state:Int) {
        switch(state) {
            case 22: //Prepare screenshake
                kbPincerPrepare(5, false);
                /*if(forceMiddleScroll)
                    kbPincerPrepare(6, false);
                else*/
                    kbPincerPrepare(4, false);
            case 23: //SHAKEY SHAKEY
                kbPincerGrab(1);
                /*if(forceMiddleScroll)
                    kbPincerGrab(2);
                else*/
                kbPincerGrab(4);
                inAngleRotating = true;
            case 24: //Screenshake end
                kbPincerPrepare(5, true);
                /*if(forceMiddleScroll)
                    kbPincerPrepare(6, true);
                else*/
                kbPincerPrepare(4, true);
                inAngleRotating = false;
                resetCameraAngle();
        }
    }

    ////--- Events 
    public function kbPincerPrepare(laneID:Int, goAway:Bool) {
        function hazardComeOnManWhatIsThisJAJAJA(daPincer:FunkinSprite, goesAway:Bool, laneID:Int) {
            var noteID:Int = -1;
            switch(laneID) { // fkin Translating-
                case 1:
                    noteID = 4;
                case 2:
                    noteID = 5;
                case 3:
                    noteID = 6;
                case 4:
                    noteID = 7;
                case 5:
                    noteID = 0;
                case 6:
                    noteID = 3;
                default: // XDXDXD
            }
            if (noteID < 0) return;
            var daArrow = getArrowNote(noteID);
            daPincer.loadTexture(Paths.image('hazardStuff/qt-port/pincer-open'));

            var daY:Float = (Preferences.downscroll ? 500 : -500);
            if(goesAway) FlxTween.tween(daPincer, {y: daArrow.y + daY}, 0.4, {ease: FlxEase.backIn});
            else {
                daPincer.setPosition(daArrow.x, daArrow.y + daY);
                FlxTween.tween(daPincer, {y: daArrow.y}, 0.3, {ease: FlxEase.elasticOut});
            }
            daPincer.visible = true;
        }

        var dummyPincer;
        switch (laneID) {
            case 1 | 5:
                dummyPincer = pincer1;
            case 2 | 6:
                dummyPincer = pincer2;
            case 3:
                dummyPincer = pincer3;
            case 4:
                dummyPincer = pincer4;
        }
        if (dummyPincer ==  null) return;
        hazardComeOnManWhatIsThisJAJAJA(dummyPincer, goAway, laneID);
	}

	function kbPincerGrab(laneID:Int):Void {
		switch(laneID) {
			case 1:
				pincer1.loadTexture(Paths.image('hazardStuff/qt-port/pincer-close'));
            case 5:
                pincer1.loadTexture(Paths.image('hazardStuff/qt-port/pincer-close'));
			case 2:
				pincer2.loadTexture(Paths.image('hazardStuff/qt-port/pincer-close'));
			case 3:
				pincer3.loadTexture(Paths.image('hazardStuff/qt-port/pincer-close'));
			case 4:
				pincer4.loadTexture(Paths.image('hazardStuff/qt-port/pincer-close'));
			default:
				trace("Fkin idiot, that laneID is wrong"); // Spicy
		}
	}

    // Screen rotating
    function cameraAngleMovement() {
        if (Conductor.instance == null || !inAngleRotating) return;
        PlayState.instance.camHUD.angle = Math.sin((Conductor.instance.songPosition / Conductor.instance.beatLengthMs) * Math.PI) * 5;
    }

    // Reset camera angle from rotating
    function resetCameraAngle() {
        if (Conductor.instance == null || inAngleRotating) return;
        PlayState.instance.camHUD.angle = 0;
    }

    function nonVisibleStaticArrows() {
        for (i in 0...PlayState.instance.playerStrumline.strumlineNotes.members.length)
            PlayState.instance.playerStrumline.strumlineNotes.members[i].visible = false;

        for (i in 0...PlayState.instance.opponentStrumline.strumlineNotes.members.length)
            PlayState.instance.opponentStrumline.strumlineNotes.members[i].visible = false;
    }

    function terminationIntroShit(state:Int) {
        if (PlayState.instance == null) return;
        var playerArrow = PlayState.instance.playerStrumline.strumlineNotes.members[3 - state];
        var opponentArrow = PlayState.instance.opponentStrumline.strumlineNotes.members[state];
        var defPy:Float = playerArrow.y;
        var defOy:Float = opponentArrow.y;

        FlxTween.cancelTweensOf(playerArrow); // Stops arrow's fading in, just in case
        FlxTween.cancelTweensOf(opponentArrow);
        shakeCameras(0.002, 0.002, 1);

        playerArrow.alpha = 0;
        opponentArrow.alpha = 0;
        playerArrow.visible = true;
        opponentArrow.visible = true;

        playerArrow.y += (Preferences.downscroll ? -25 : 25);
        FlxTween.tween(playerArrow, {y: defPy, alpha: 1}, 1.22, {ease: FlxEase.cubeOut});
        opponentArrow.y += (Preferences.downscroll ? -25 : 25);
        FlxTween.tween(opponentArrow, {y: defOy, alpha: 1}, 1.22, {ease: FlxEase.cubeOut});
	}

    function terminationOutroShit(state:Int, isPlayer:Bool) {
        if (PlayState.instance == null) return;
        var daArrow = (isPlayer ? PlayState.instance.playerStrumline.strumlineNotes.members[state] : PlayState.instance.opponentStrumline.strumlineNotes.members[state - 4]);
        FlxTween.tween(daArrow, {alpha: 0}, 1.1, {ease: FlxEase.sineInOut});
    }
    ////---Fkin Arrow Helpers
    // Initializes the Arrow def positions map, with all the "posible arrows"
    function initDefArrowPos() {
        defPosArray = [];
        if (PlayState.instance == null) return;

        for (i in 0...PlayState.instance.opponentStrumline.strumlineNotes.members.length) {
            var daArrow = getArrowNote(i);
            fkinOpponentPosArray.push(FlxPoint.get(daArrow.x, daArrow.y));
        }
        for (i in 0...PlayState.instance.playerStrumline.strumlineNotes.members.length) {
            var daArrow = getArrowNote(i + 4);
            fkinPlayerPosArray.push(FlxPoint.get(daArrow.x, daArrow.y));
        }
    }

    // Returns an static arrow. 0-3: Opponent Arrows; 4-7 Player Arrows;
    function getArrowNote(note:Int):StrumlineNote {
        if (note < 4) return PlayState.instance.opponentStrumline.strumlineNotes.members[note];
        return PlayState.instance.playerStrumline.strumlineNotes.members[note - 4];
    }

    // Gets an FlxPoint from the positions
	function getArrowDefPos(key:Int):FlxPoint {
        if (key > 3) return fkinPlayerPosArray[key - 4];
        return fkinOpponentPosArray[key];
	}
}