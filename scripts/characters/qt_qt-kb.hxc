import funkin.graphics.adobeanimate.FlxAtlasSprite;
import flixel.FlxG;
import funkin.audio.FunkinSound;
import funkin.play.character.MultiSparrowCharacter;
import funkin.play.GameOverSubState;
import funkin.play.PlayState;
import funkin.Preferences;
import funkin.util.Constants;
import funkin.util.HapticUtil;

using StringTools;

class VsQTdaQTandKillerBotCharacter extends MultiSparrowCharacter
{
  var qt_hpDrainMultiplier:Float = 0.5925;
  var qt_lossMultiplier:Float = 1.0;
  public var animSuffix:String = "";
  function new()
  {
    super('qt_qt-kb');
  }

  function onCreate(event:ScriptEvent)
  {
    super.onCreate(event);

    setDrain(0.01185, 1.0);
  }

  override function onUpdate(event:UpdateScriptEvent):Void {
    super.onUpdate(event);

    drainHoldNote(event.elapsed);
  }

  function onSongRetry(event:ScriptEvent) {
    super.onSongRetry(event);

    setDrain(0.01185, 1.0);
    animSuffix = "";
    this.idleSuffix = '';
    this.shouldAlternate = true;
  }

  override public function playSingAnimation(dir:NoteDirection, miss:Bool = false, ?suffix:String = ''):Void
  {
    super.playSingAnimation(dir, miss, animSuffix + suffix);
  }

  function onNoteHit(event:HitNoteScriptEvent) {
		super.onNoteHit(event);

		if (PlayState.instance == null) return;

		if (!event.note.noteData.getMustHitNote() && canDrain(Constants.HEALTH_SICK_BONUS)) {
        PlayState.instance.health -= (Constants.HEALTH_SICK_BONUS * qt_hpDrainMultiplier) / ((FlxG.onMobile) ? 2 : 1);
		}
	}

  function onNoteMiss(event:NoteScriptEvent) {
    super.onNoteMiss(event);

    if (PlayState.instance == null) return;
    var lossMult:Float = 1 - qt_lossMultiplier;
    PlayState.instance.health += (Constants.HEALTH_MISS_PENALTY * lossMult);
  }

  function drainHoldNote(elapsed:Float) {
    for (holdNote in PlayState.instance.opponentStrumline.holdNotes.members)
    {
      if (holdNote == null || !holdNote.alive || holdNote.noteData == null) continue;

      // While the hold note is being hit, and there is length on the hold note...
      if (holdNote.hitNote && !holdNote.missedNote && holdNote.sustainLength > 0 && canDrain(Constants.HEALTH_HOLD_BONUS_PER_SECOND)) {
        PlayState.instance.health -= ((Constants.HEALTH_HOLD_BONUS_PER_SECOND * qt_hpDrainMultiplier) * elapsed) / ((FlxG.onMobile) ? 2 : 1);
      }
    }
  }

  // Sooo this gets a value, and then converts it into a multiplier for the V-Slice health drain
  // in QT, the HP gained when hitting a note is 0.02, in V-Slice is 0.03 (I think)
  // Soo, to get the HPdrain equivalent here, we divide the QT mod value by its HP gain (0.02)
  function setDrain(rawDrainValue:Float, rawLossMultiplier:Float = null):Void {
    if (rawDrainValue != null) this.qt_hpDrainMultiplier = rawDrainValue / 0.02; // 0.02 is the healthDrain on QT mod (I think)
    if (rawLossMultiplier != null) this.qt_lossMultiplier = rawLossMultiplier;
  }

  function canDrain(drain:Float):Bool {
    if (animSuffix == "") return false;
    if (PlayState.instance == null) return false;
    if (drain == null) return false;

    return (PlayState.instance.health - qt_hpDrainMultiplier*drain - 0.1 > Constants.HEALTH_MIN);
  }
}
